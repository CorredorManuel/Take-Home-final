# Q2
k <- trunc(N/4)
ValorCritico <- qchisq(p = 0.95,df = p,FALSE)
if( ValorCritico >Q23[p] ) {
resultado1 <- "no se rechaza la hipotesis nula,son rudio blanco"
} else {
resultado1 <- "se rechaza la hipotesis nula,no son ruido blanco"
}
guardar2[p,1] <- cbind(significancia[indice])
guardar2[p,2] <- cbind(resultado1)
}
pacf(matriz)
pacf(diff(matriz))
pacf(matriz)
# de la serie que genere Ruido Blanco y donde su coeficiente sea significante
# respetando que el modelo sea parsimonioso
# Creación de dos funciones que crean una matriz de lags
myLag <- function(x, n){
if(n >= length(x))
return(rep(NA,n))
else if(n < length(x) & n > 0)
c(rep(NA,n), x[1:(length(x)-n)])
}
lagit <- function(x,y){#ESTA FUNCION GUARDA LOS LAGS EN COLUMNAS
cbind(x, sapply(y, function(z) myLag(x,z)))
}
#Creación de funcion que calcula las actocorrelaciones parciales
ACFfun00 <- function(Z,K){
media <- 0
N <- length(Z)
ACF <- matrix(data = NA,nrow = (K+1),ncol = 1)#creación vector vacio
for(k in 0:K){
Zk <- Z[(k+1):N] # valor eliminados al inicio
Zklag <- Z[1:(N-k)] #valores eliminados al final
numerador <- sum((Zk-media)*(Zklag-media))
denominador <- sum((Z-media)^2)
ACF[k+1] <- numerador/denominador
}
#plot(ACF,type="h")
return(ACF)
}
#Importacion de Datos
library(readxl)
datos <- read_excel("datos.xlsx")
pma <- 100
pmax <- pma-1
identificacion <- matrix(nrow = pmax,ncol = 2)
#matriz <- diff(datos$NEQUI) #
matriz <- (datos$NEQUI) #
for (p in 1:pmax){
# Creación de variables requeridas
Y <- matrix()
Y_D <- matrix()
X <- matrix()
dY_D <- matrix()
valores <- length(matriz)
#p <- 46 #orden P ha evaluar
filas <- 3 #coefientes TauTau "intercepto,tendencia y gamma)
modelo <- matrix(data = NA,nrow =(filas+p) ,ncol =1) #matriz para guardar coeficientes
Y <- matriz[(1:valores-1)]
for(k in 2:valores){ #calculo de delta de Y
Y_D[k-1] <-  matriz[k]-matriz[k-1]
}
dY_D  <- lagit(Y_D,1:(p)) #Aplicacion de la funcion de Lags
dY_D <- dY_D[,2:(p+1)]
#X <-  cbind(1,seq(from=1,to=valores-1),Y,dY_D)# Creacion matriz de diseño
X <- cbind(1,seq(from=1,to=valores-1),Y,dY_D)# Creacion matriz de diseño
X <- X[-c(1:p),]# Ajuste de la matriz eliminando valorres NA
Y_D <- Y_D[-c(1:p)]
modelo[,1] <- solve(t(X)%*%X)%*%t(X)%*%Y_D #Regresión del modelo
indice <- dim(modelo)[1]
df <- dim(X)[1]-dim(X)[2]
ygorro <- (X%*%modelo[1:indice])
egorro <- c(Y_D-ygorro)
N <- length(egorro)
vare <- (1/(N-1))*sum(t(egorro)%*%egorro)
varcov <- vare*solve(t(X)%*%X)
verificarse <- c()
significancia <- c()
rfinal <- c()
for(i in 1:(filas+p)){
verificarse[i] <- modelo[i,1]/sqrt(varcov[i,i])
verificarse
izquierda <- qt(0.025,N-indice)#cola izquierda
derecha <- qt(0.025,N-indice,lower.tail = FALSE)
if(verificarse[i]>izquierda & verificarse[i]< derecha) { #alta potencia
significancia[i] <-  "No se puede rechazar que el coeficiente sea 0, no es significativo"
}else{
significancia[i] <- "Se puede rechazar que el coeficiente sea O,es significativo"
}
}
resultado1 <- c()
k <- trunc(N/4) # 100 poner un valor para correr mayor a 50
Rho_residuales <- ACFfun00(egorro,k)
#Q23 <- (N)*(N+2)*(sum(Rho_residuales[(2:p)]**2))/(N-p)
Q23 <- matrix (NA,p,2)
for (i in 1:p){
b<-Box.test(matriz, lag =i, type="Ljung")
Q23[i,] <- c(b$statistic , b$p.value )
}
colnames(Q23) <-  c("statistic", "p.value")
k <- trunc(N/4)
ValorCritico <- qchisq(p = 0.95,df = p,FALSE)
if( ValorCritico >Q23[p] ) {
resultado1 <- "no se rechaza la hipotesis nula,son rudio blanco"
} else {
resultado1 <- "se rechaza la hipotesis nula,no son ruido blanco"
}
identificacion[p,1] <- cbind(significancia[indice])
identificacion[p,2] <- cbind(resultado1)
}
View(identificacion)
acf(matriz)
pacf(matriz)
identificacion
cbind(identificacion)
View(identificacion)
#matriz <- diff(datos$NEQUI) #
#matriz <- (datos$NEQUI) #Datos para el analisis
orden_p <- function(datos,pmax){
matriz <- datos
identificacion <- matrix(nrow = pmax,ncol = 2)
for (p in 1:pmax){
# Creación de variables requeridas
Y <- matrix()
Y_D <- matrix()
X <- matrix()
dY_D <- matrix()
valores <- length(matriz)
#p <- 46 #orden P ha evaluar
filas <- 3 #coefientes TauTau "intercepto,tendencia y gamma)
modelo <- matrix(data = NA,nrow =(filas+p) ,ncol =1) #matriz para guardar coeficientes
Y <- matriz[(1:valores-1)]
for(k in 2:valores){ #calculo de delta de Y
Y_D[k-1] <-  matriz[k]-matriz[k-1]
}
dY_D  <- lagit(Y_D,1:(p)) #Aplicacion de la funcion de Lags
dY_D <- dY_D[,2:(p+1)]
#X <-  cbind(1,seq(from=1,to=valores-1),Y,dY_D)# Creacion matriz de diseño
X <- cbind(1,seq(from=1,to=valores-1),Y,dY_D)# Creacion matriz de diseño
X <- X[-c(1:p),]# Ajuste de la matriz eliminando valorres NA
Y_D <- Y_D[-c(1:p)]
modelo[,1] <- solve(t(X)%*%X)%*%t(X)%*%Y_D #Regresión del modelo
indice <- dim(modelo)[1]
df <- dim(X)[1]-dim(X)[2]
ygorro <- (X%*%modelo[1:indice])
egorro <- c(Y_D-ygorro)
N <- length(egorro)
vare <- (1/(N-1))*sum(t(egorro)%*%egorro)
varcov <- vare*solve(t(X)%*%X)
verificarse <- c()
significancia <- c()
rfinal <- c()
for(i in 1:(filas+p)){
verificarse[i] <- modelo[i,1]/sqrt(varcov[i,i])
verificarse
izquierda <- qt(0.025,N-indice)#cola izquierda
derecha <- qt(0.025,N-indice,lower.tail = FALSE)
if(verificarse[i]>izquierda & verificarse[i]< derecha) { #alta potencia
significancia[i] <-  "No se puede rechazar que el coeficiente sea 0, no es significativo"
}else{
significancia[i] <- "Se puede rechazar que el coeficiente sea O,es significativo"
}
}
resultado1 <- c()
k <- trunc(N/4) # 100 poner un valor para correr mayor a 50
Rho_residuales <- ACFfun00(egorro,k)
#Q23 <- (N)*(N+2)*(sum(Rho_residuales[(2:p)]**2))/(N-p)
Q23 <- matrix (NA,p,2)
for (i in 1:p){
b<-Box.test(matriz, lag =i, type="Ljung")
Q23[i,] <- c(b$statistic , b$p.value )
}
colnames(Q23) <-  c("statistic", "p.value")
k <- trunc(N/4)
ValorCritico <- qchisq(p = 0.95,df = p,FALSE)
if( ValorCritico >Q23[p] ) {
resultado1 <- "no se rechaza la hipotesis nula,son rudio blanco"
} else {
resultado1 <- "se rechaza la hipotesis nula,no son ruido blanco"
}
identificacion[p,1] <- cbind(significancia[indice])
identificacion[p,2] <- cbind(resultado1)
}
}
orden_p((datos$NEQUI),100)
# Creación de dos funciones que crean una matriz de lags
myLag <- function(x, n){
if(n >= length(x))
return(rep(NA,n))
else if(n < length(x) & n > 0)
c(rep(NA,n), x[1:(length(x)-n)])
}
lagit <- function(x,y){#ESTA FUNCION GUARDA LOS LAGS EN COLUMNAS
cbind(x, sapply(y, function(z) myLag(x,z)))
}
#Creación de funcion que calcula las actocorrelaciones parciales
ACFfun00 <- function(Z,K){
media <- 0
N <- length(Z)
ACF <- matrix(data = NA,nrow = (K+1),ncol = 1)#creación vector vacio
for(k in 0:K){
Zk <- Z[(k+1):N] # valor eliminados al inicio
Zklag <- Z[1:(N-k)] #valores eliminados al final
numerador <- sum((Zk-media)*(Zklag-media))
denominador <- sum((Z-media)^2)
ACF[k+1] <- numerador/denominador
}
#plot(ACF,type="h")
return(ACF)
}
#Importacion de Datos
library(readxl)
datos <- read_excel("datos.xlsx")
#matriz <- diff(datos$NEQUI) #
#matriz <- (datos$NEQUI) #Datos para el analisis
orden_p <- function(datos,pmax){
matriz <- datos
identificacion <- matrix(nrow = pmax,ncol = 2)
for (p in 1:pmax){
# Creación de variables requeridas
Y <- matrix()
Y_D <- matrix()
X <- matrix()
dY_D <- matrix()
valores <- length(matriz)
#p <- 46 #orden P ha evaluar
filas <- 3 #coefientes TauTau "intercepto,tendencia y gamma)
modelo <- matrix(data = NA,nrow =(filas+p) ,ncol =1) #matriz para guardar coeficientes
Y <- matriz[(1:valores-1)]
for(k in 2:valores){ #calculo de delta de Y
Y_D[k-1] <-  matriz[k]-matriz[k-1]
}
dY_D  <- lagit(Y_D,1:(p)) #Aplicacion de la funcion de Lags
dY_D <- dY_D[,2:(p+1)]
#X <-  cbind(1,seq(from=1,to=valores-1),Y,dY_D)# Creacion matriz de diseño
X <- cbind(1,seq(from=1,to=valores-1),Y,dY_D)# Creacion matriz de diseño
X <- X[-c(1:p),]# Ajuste de la matriz eliminando valorres NA
Y_D <- Y_D[-c(1:p)]
modelo[,1] <- solve(t(X)%*%X)%*%t(X)%*%Y_D #Regresión del modelo
indice <- dim(modelo)[1]
df <- dim(X)[1]-dim(X)[2]
ygorro <- (X%*%modelo[1:indice])
egorro <- c(Y_D-ygorro)
N <- length(egorro)
vare <- (1/(N-1))*sum(t(egorro)%*%egorro)
varcov <- vare*solve(t(X)%*%X)
verificarse <- c()
significancia <- c()
rfinal <- c()
for(i in 1:(filas+p)){
verificarse[i] <- modelo[i,1]/sqrt(varcov[i,i])
verificarse
izquierda <- qt(0.025,N-indice)#cola izquierda
derecha <- qt(0.025,N-indice,lower.tail = FALSE)
if(verificarse[i]>izquierda & verificarse[i]< derecha) { #alta potencia
significancia[i] <-  "No se puede rechazar que el coeficiente sea 0, no es significativo"
}else{
significancia[i] <- "Se puede rechazar que el coeficiente sea O,es significativo"
}
}
resultado1 <- c()
k <- trunc(N/4) # 100 poner un valor para correr mayor a 50
Rho_residuales <- ACFfun00(egorro,k)
#Q23 <- (N)*(N+2)*(sum(Rho_residuales[(2:p)]**2))/(N-p)
Q23 <- matrix (NA,p,2)
for (i in 1:p){
b<-Box.test(matriz, lag =i, type="Ljung")
Q23[i,] <- c(b$statistic , b$p.value )
}
colnames(Q23) <-  c("statistic", "p.value")
k <- trunc(N/4)
ValorCritico <- qchisq(p = 0.95,df = p,FALSE)
if( ValorCritico >Q23[p] ) {
resultado1 <- "no se rechaza la hipotesis nula,son rudio blanco"
} else {
resultado1 <- "se rechaza la hipotesis nula,no son ruido blanco"
}
identificacion[p,1] <- cbind(significancia[indice])
identificacion[p,2] <- cbind(resultado1)
}
}
orden_p((datos$NEQUI),100)
guardfwes <- orden_p((datos$NEQUI),100)
#View(identificacion)  ##se revisa si el orden p genera Ruido Blanco y si es significante
## se concluye que
pacf(matriz)
datos <- read_excel("datos.xlsx")
guardfwes <- orden_p(datos$NEQUI,100)
guardfwes
# Creación de dos funciones que crean una matriz de lags
myLag <- function(x, n){
if(n >= length(x))
return(rep(NA,n))
else if(n < length(x) & n > 0)
c(rep(NA,n), x[1:(length(x)-n)])
}
lagit <- function(x,y){#ESTA FUNCION GUARDA LOS LAGS EN COLUMNAS
cbind(x, sapply(y, function(z) myLag(x,z)))
}
#Creación de funcion que calcula las actocorrelaciones parciales
ACFfun00 <- function(Z,K){
media <- 0
N <- length(Z)
ACF <- matrix(data = NA,nrow = (K+1),ncol = 1)#creación vector vacio
for(k in 0:K){
Zk <- Z[(k+1):N] # valor eliminados al inicio
Zklag <- Z[1:(N-k)] #valores eliminados al final
numerador <- sum((Zk-media)*(Zklag-media))
denominador <- sum((Z-media)^2)
ACF[k+1] <- numerador/denominador
}
#plot(ACF,type="h")
return(ACF)
}
#Importacion de Datos
library(readxl)
datos <- read_excel("datos.xlsx")
pmax <- 100 #especifico un P maximo para la verificación
identificacion <- matrix(nrow = pmax,ncol = 2)
#matriz <- diff(datos$NEQUI) #
matriz <- (datos$NEQUI) #Datos para el analisis
for (p in 1:pmax){
# Creación de variables requeridas
Y <- matrix()
Y_D <- matrix()
X <- matrix()
dY_D <- matrix()
valores <- length(matriz)
#p <- 46 #orden P ha evaluar
filas <- 3 #coefientes TauTau "intercepto,tendencia y gamma)
modelo <- matrix(data = NA,nrow =(filas+p) ,ncol =1) #matriz para guardar coeficientes
Y <- matriz[(1:valores-1)]
for(k in 2:valores){ #calculo de delta de Y
Y_D[k-1] <-  matriz[k]-matriz[k-1]
}
dY_D  <- lagit(Y_D,1:(p)) #Aplicacion de la funcion de Lags
dY_D <- dY_D[,2:(p+1)]
#X <-  cbind(1,seq(from=1,to=valores-1),Y,dY_D)# Creacion matriz de diseño
X <- cbind(1,seq(from=1,to=valores-1),Y,dY_D)# Creacion matriz de diseño
X <- X[-c(1:p),]# Ajuste de la matriz eliminando valorres NA
Y_D <- Y_D[-c(1:p)]
modelo[,1] <- solve(t(X)%*%X)%*%t(X)%*%Y_D #Regresión del modelo
indice <- dim(modelo)[1]
df <- dim(X)[1]-dim(X)[2]
ygorro <- (X%*%modelo[1:indice])
egorro <- c(Y_D-ygorro)
N <- length(egorro)
vare <- (1/(N-1))*sum(t(egorro)%*%egorro)
varcov <- vare*solve(t(X)%*%X)
verificarse <- c()
significancia <- c()
rfinal <- c()
for(i in 1:(filas+p)){
verificarse[i] <- modelo[i,1]/sqrt(varcov[i,i])
verificarse
izquierda <- qt(0.025,N-indice)#cola izquierda
derecha <- qt(0.025,N-indice,lower.tail = FALSE)
if(verificarse[i]>izquierda & verificarse[i]< derecha) { #alta potencia
significancia[i] <-  "No se puede rechazar que el coeficiente sea 0, no es significativo"
}else{
significancia[i] <- "Se puede rechazar que el coeficiente sea O,es significativo"
}
}
resultado1 <- c()
k <- trunc(N/4) # 100 poner un valor para correr mayor a 50
Rho_residuales <- ACFfun00(egorro,k)
#Q23 <- (N)*(N+2)*(sum(Rho_residuales[(2:p)]**2))/(N-p)
Q23 <- matrix (NA,p,2)
for (i in 1:p){
b<-Box.test(matriz, lag =i, type="Ljung")
Q23[i,] <- c(b$statistic , b$p.value )
}
colnames(Q23) <-  c("statistic", "p.value")
k <- trunc(N/4)
ValorCritico <- qchisq(p = 0.95,df = p,FALSE)
if( ValorCritico >Q23[p] ) {
resultado1 <- "no se rechaza la hipotesis nula,son rudio blanco"
} else {
resultado1 <- "se rechaza la hipotesis nula,no son ruido blanco"
}
identificacion[p,1] <- cbind(significancia[indice])
identificacion[p,2] <- cbind(resultado1)
}
identificacion
#View(identificacion)  ##se revisa si el orden p genera Ruido Blanco y si es significante
### verificación visual de la significancia del orden P,
base <-ggplot() + xlim(-8, 8)+
geom_function(aes(colour = "t, df = N-K"), fun = dt, args = list(df = df))+
stat_function(fun = dnorm, geom = "polygon", color = "black", fill = "green", alpha = 0.5)+
geom_vline(aes(xintercept=izquierda),linetype="dashed",color="red")+
geom_vline(aes(xintercept=derecha),linetype="dashed",color="red")+
geom_vline(aes(xintercept=verificarse[length(verificarse)]),linetype="dashed",color="blue")+ #aca modifique la posicion
geom_density(fill="black", alpha = .5)+
theme(legend.position = c(0.2, 0.9),
legend.background = element_rect(fill = "white"))
base + labs(title = 'Curva de distribución t',subtitle = 'verificacion de significancia del coeficiente P de ADF',color='valor t estadistico')
pmax <- 46 #especifico un P maximo para la verificación
identificacion <- matrix(nrow = pmax,ncol = 2)
#matriz <- diff(datos$NEQUI) #
matriz <- (datos$NEQUI) #Datos para el analisis
for (p in 1:pmax){
# Creación de variables requeridas
Y <- matrix()
Y_D <- matrix()
X <- matrix()
dY_D <- matrix()
valores <- length(matriz)
#p <- 46 #orden P ha evaluar
filas <- 3 #coefientes TauTau "intercepto,tendencia y gamma)
modelo <- matrix(data = NA,nrow =(filas+p) ,ncol =1) #matriz para guardar coeficientes
Y <- matriz[(1:valores-1)]
for(k in 2:valores){ #calculo de delta de Y
Y_D[k-1] <-  matriz[k]-matriz[k-1]
}
dY_D  <- lagit(Y_D,1:(p)) #Aplicacion de la funcion de Lags
dY_D <- dY_D[,2:(p+1)]
#X <-  cbind(1,seq(from=1,to=valores-1),Y,dY_D)# Creacion matriz de diseño
X <- cbind(1,seq(from=1,to=valores-1),Y,dY_D)# Creacion matriz de diseño
X <- X[-c(1:p),]# Ajuste de la matriz eliminando valorres NA
Y_D <- Y_D[-c(1:p)]
modelo[,1] <- solve(t(X)%*%X)%*%t(X)%*%Y_D #Regresión del modelo
indice <- dim(modelo)[1]
df <- dim(X)[1]-dim(X)[2]
ygorro <- (X%*%modelo[1:indice])
egorro <- c(Y_D-ygorro)
N <- length(egorro)
vare <- (1/(N-1))*sum(t(egorro)%*%egorro)
varcov <- vare*solve(t(X)%*%X)
verificarse <- c()
significancia <- c()
rfinal <- c()
for(i in 1:(filas+p)){
verificarse[i] <- modelo[i,1]/sqrt(varcov[i,i])
verificarse
izquierda <- qt(0.025,N-indice)#cola izquierda
derecha <- qt(0.025,N-indice,lower.tail = FALSE)
if(verificarse[i]>izquierda & verificarse[i]< derecha) { #alta potencia
significancia[i] <-  "No se puede rechazar que el coeficiente sea 0, no es significativo"
}else{
significancia[i] <- "Se puede rechazar que el coeficiente sea O,es significativo"
}
}
resultado1 <- c()
k <- trunc(N/4) # 100 poner un valor para correr mayor a 50
Rho_residuales <- ACFfun00(egorro,k)
#Q23 <- (N)*(N+2)*(sum(Rho_residuales[(2:p)]**2))/(N-p)
Q23 <- matrix (NA,p,2)
for (i in 1:p){
b<-Box.test(matriz, lag =i, type="Ljung")
Q23[i,] <- c(b$statistic , b$p.value )
}
colnames(Q23) <-  c("statistic", "p.value")
k <- trunc(N/4)
ValorCritico <- qchisq(p = 0.95,df = p,FALSE)
if( ValorCritico >Q23[p] ) {
resultado1 <- "no se rechaza la hipotesis nula,son rudio blanco"
} else {
resultado1 <- "se rechaza la hipotesis nula,no son ruido blanco"
}
identificacion[p,1] <- cbind(significancia[indice])
identificacion[p,2] <- cbind(resultado1)
}
#View(identificacion)  ##se revisa si el orden p genera Ruido Blanco y si es significante
### verificación visual de la significancia del orden P "en este caso se encuentra siginifica en el orden p= 46"
base <-ggplot() + xlim(-8, 8)+
geom_function(aes(colour = "t, df = N-K"), fun = dt, args = list(df = df))+
stat_function(fun = dnorm, geom = "polygon", color = "black", fill = "green", alpha = 0.5)+
geom_vline(aes(xintercept=izquierda),linetype="dashed",color="red")+
geom_vline(aes(xintercept=derecha),linetype="dashed",color="red")+
geom_vline(aes(xintercept=verificarse[length(verificarse)]),linetype="dashed",color="blue")+ #aca modifique la posicion
geom_density(fill="black", alpha = .5)+
theme(legend.position = c(0.2, 0.9),
legend.background = element_rect(fill = "white"))
base + labs(title = 'Curva de distribución t',subtitle = 'verificacion de significancia del coeficiente P de ADF',color='valor t estadistico')
# de la serie que genere Ruido Blanco y donde su coeficiente sea significante
# respetando que el modelo sea parsimonioso
# Creación de dos funciones que crean una matriz de lags
myLag <- function(x, n){
if(n >= length(x))
return(rep(NA,n))
else if(n < length(x) & n > 0)
c(rep(NA,n), x[1:(length(x)-n)])
}
lagit <- function(x,y){#ESTA FUNCION GUARDA LOS LAGS EN COLUMNAS
cbind(x, sapply(y, function(z) myLag(x,z)))
}
#Creación de funcion que calcula las actocorrelaciones parciales
ACFfun00 <- function(Z,K){
media <- 0
N <- length(Z)
ACF <- matrix(data = NA,nrow = (K+1),ncol = 1)#creación vector vacio
for(k in 0:K){
Zk <- Z[(k+1):N] # valor eliminados al inicio
Zklag <- Z[1:(N-k)] #valores eliminados al final
numerador <- sum((Zk-media)*(Zklag-media))
denominador <- sum((Z-media)^2)
ACF[k+1] <- numerador/denominador
}
#plot(ACF,type="h")
return(ACF)
}
library(readxl)
datos <- read_excel("Datos PIB y exportaciones.xlsx")
datos <- read_excel("Datos PIB y exportaciones.xlsx")
library(readxl)
datos <- read_excel("Datos PIB y exportaciones.xlsx")
datos <- read_excel("~/Documents/GitHub/Take Home final/Datos PIB y exportaciones.xlsx")
library(readxl)
Datos_PIB_y_exportaciones <- read_excel("Datos PIB y exportaciones.xlsx")
library(readxl)
Libro1 <- read_excel("Libro1.xlsx")
